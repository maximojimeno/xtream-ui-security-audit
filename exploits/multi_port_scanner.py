#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
EXPLOIT: Scanner Multi-Puerto para Xtream UI
Escanea todos los puertos conocidos de Xtream UI automáticamente

Puertos escaneados:
    - 25500: Admin Panel
    - 25461: HTTP Streaming API
    - 25462: RTMP Streaming
    - 25463: HTTPS Streaming
    - 7999:  MySQL Database
    - 22:    SSH
    - Puertos personalizados

Autor: Security Research
Fecha: 2026-01-29
"""

import sys
import socket
import urllib.request
import urllib.error
import base64
import json

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


class MultiPortScanner:
    """Scanner de múltiples puertos para Xtream UI"""
    
    # Puertos conocidos de Xtream UI
    KNOWN_PORTS = {
        25500: "Admin Panel",
        25461: "HTTP Streaming API",
        25462: "RTMP Streaming",
        25463: "HTTPS Streaming",
        7999: "MySQL Database",
        22: "SSH",
        80: "HTTP (alternat.)",
        443: "HTTPS (alternat.)",
        8080: "HTTP Proxy (alternat.)"
    }
    
    def __init__(self, target, custom_ports=None):
        self.target = target
        self.custom_ports = custom_ports or []
        self.open_ports = []
        self.vulnerabilities = []
        
    def print_banner(self):
        """Banner del scanner"""
        banner = """
{}╔═══════════════════════════════════════════════════════════╗
║       Xtream UI Multi-Port Vulnerability Scanner       ║
║              Escaneo Completo de Servicios              ║
╚═══════════════════════════════════════════════════════════╝{}

{}[*]{} Target: {}{}{}
{}[*]{} Puertos a escanear: {}{}{}
        """.format(
            Colors.HEADER, Colors.ENDC,
            Colors.OKBLUE, Colors.ENDC, Colors.WARNING, self.target, Colors.ENDC,
            Colors.OKBLUE, Colors.ENDC, Colors.WARNING, 
            len(self.KNOWN_PORTS) + len(self.custom_ports), Colors.ENDC
        )
        print(banner)
    
    def check_port(self, port, timeout=3):
        """Verifica si un puerto está abierto"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((self.target, port))
            sock.close()
            return result == 0
        except Exception:
            return False
    
    def scan_all_ports(self):
        """Escanea todos los puertos conocidos"""
        print("\n{}[*]{} Escaneando puertos conocidos de Xtream UI...\n".format(
            Colors.OKBLUE, Colors.ENDC
        ))
        
        all_ports = dict(self.KNOWN_PORTS)
        
        # Añadir puertos personalizados
        for port in self.custom_ports:
            all_ports[port] = "Puerto personalizado"
        
        for port, service in sorted(all_ports.items()):
            sys.stdout.write("    Probando puerto {}{}{} ({})... ".format(
                Colors.WARNING, port, Colors.ENDC, service
            ))
            sys.stdout.flush()
            
            if self.check_port(port):
                print("{}✓ ABIERTO{}".format(Colors.OKGREEN, Colors.ENDC))
                self.open_ports.append({
                    'port': port,
                    'service': service,
                    'status': 'open'
                })
            else:
                print("{}✗ Cerrado{}".format(Colors.FAIL, Colors.ENDC))
    
    def check_admin_panel(self, port):
        """Verifica panel de administración"""
        try:
            url = f"http://{self.target}:{port}"
            req = urllib.request.Request(url)
            req.add_header('User-Agent', 'Mozilla/5.0')
            
            response = urllib.request.urlopen(req, timeout=5)
            content = response.read().decode('utf-8', errors='ignore')
            
            # Detectar Xtream UI
            if any(x in content.lower() for x in ['xtream', 'admin', 'login']):
                return True
        except:
            pass
        return False
    
    def check_default_creds(self, port):
        """Verifica credenciales por defecto"""
        try:
            auth_string = base64.b64encode(b"admin:admin").decode('ascii')
            headers = {
                'Authorization': 'Basic {}'.format(auth_string),
                'User-Agent': 'Mozilla/5.0'
            }
            
            url = "http://{}:{}/login.php".format(self.target, port)
            req = urllib.request.Request(url, headers=headers)
            response = urllib.request.urlopen(req, timeout=5)
            content = response.read().decode('utf-8', errors='ignore')
            
            if "dashboard" in content.lower() or "logout" in content.lower():
                return True
        except urllib.error.HTTPError as e:
            if e.code == 401:
                return False
        except:
            pass
        return False
    
    def deep_scan_port(self, port_info):
        """Análisis profundo de un puerto abierto"""
        port = port_info['port']
        service = port_info['service']
        
        print("\n{}[*]{} Analizando puerto {}{}{} ({})...".format(
            Colors.OKBLUE, Colors.ENDC, Colors.WARNING, port, Colors.ENDC, service
        ))
        
        vulnerabilities = []
        
        # Si es puerto HTTP (probablemente admin o API)
        if port in [25500, 25461, 25463, 80, 443, 8080] or "admin" in service.lower():
            
            # Check 1: ¿Es panel de Xtream UI?
            if self.check_admin_panel(port):
                print("  {}[+]{} Panel Xtream UI detectado".format(Colors.OKGREEN, Colors.ENDC))
                vulnerabilities.append({
                    'type': 'Xtream UI Detected',
                    'severity': 'INFO',
                    'port': port
                })
                
                # Check 2: Credenciales por defecto
                if self.check_default_creds(port):
                    print("  {}[VULN]{} {}Credenciales por defecto ACTIVAS{} (admin/admin)".format(
                        Colors.FAIL, Colors.ENDC, Colors.BOLD, Colors.ENDC
                    ))
                    vulnerabilities.append({
                        'type': 'Default Credentials',
                        'severity': 'CRITICAL',
                        'port': port,
                        'creds': 'admin/admin'
                    })
                else:
                    print("  {}[+]{} Credenciales por defecto no funcionan".format(
                        Colors.OKGREEN, Colors.ENDC
                    ))
                
                # Check 3: Archivos sensibles
                self.check_exposed_files(port)
            
        # Si es MySQL
        elif port == 7999:
            print("  {}[!]{} MySQL detectado - Puede contener credenciales débiles".format(
                Colors.WARNING, Colors.ENDC
            ))
            vulnerabilities.append({
                'type': 'MySQL Exposed',
                'severity': 'HIGH',
                'port': port
            })
        
        # Si es SSH
        elif port == 22:
            print("  {}[!]{} SSH detectado - Potencial para acceso post-explotación".format(
                Colors.WARNING, Colors.ENDC
            ))
        
        port_info['vulnerabilities'] = vulnerabilities
        self.vulnerabilities.extend(vulnerabilities)
    
    def check_exposed_files(self, port):
        """Verifica archivos sensibles en puerto web"""
        sensitive = ['/config', '/database.sql', '/admin/', '/phpinfo.php']
        
        for path in sensitive:
            try:
                url = f"http://{self.target}:{port}{path}"
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'Mozilla/5.0')
                response = urllib.request.urlopen(req, timeout=3)
                
                if response.code == 200:
                    print("  {}[VULN]{} Archivo expuesto: {}".format(
                        Colors.FAIL, Colors.ENDC, path
                    ))
            except:
                pass
    
    def generate_report(self):
        """Genera reporte final"""
        print("\n\n{}╔═══════════════════════════════════════════════════════════╗".format(Colors.HEADER))
        print("{}║                  RESUMEN DEL ESCANEO                    ║".format(Colors.HEADER))
        print("{}╚═══════════════════════════════════════════════════════════╝{}\n".format(Colors.HEADER, Colors.ENDC))
        
        # Puertos abiertos
        if self.open_ports:
            print("{}[+]{} Puertos abiertos encontrados: {}{}{}\n".format(
                Colors.OKGREEN, Colors.ENDC, Colors.BOLD, len(self.open_ports), Colors.ENDC
            ))
            
            for port_info in self.open_ports:
                print("  {}→ Puerto {}{}{}: {}{}{}".format(
                    Colors.OKBLUE,
                    Colors.WARNING, port_info['port'], Colors.ENDC,
                    Colors.BOLD, port_info['service'], Colors.ENDC
                ))
        else:
            print("{}[-]{} No se encontraron puertos abiertos\n".format(
                Colors.FAIL, Colors.ENDC
            ))
        
        # Vulnerabilidades
        if self.vulnerabilities:
            print("\n{}[!]{} Vulnerabilidades encontradas: {}{}{}\n".format(
                Colors.FAIL, Colors.ENDC, Colors.BOLD, len(self.vulnerabilities), Colors.ENDC
            ))
            
            critical = [v for v in self.vulnerabilities if v['severity'] == 'CRITICAL']
            high = [v for v in self.vulnerabilities if v['severity'] == 'HIGH']
            
            if critical:
                print("  {}CRÍTICAS:{} {}".format(Colors.FAIL, Colors.ENDC, len(critical)))
                for v in critical:
                    print("    - {} (Puerto {})".format(v['type'], v['port']))
            
            if high:
                print("  {}ALTAS:{} {}".format(Colors.WARNING, Colors.ENDC, len(high)))
                for v in high:
                    print("    - {} (Puerto {})".format(v['type'], v['port']))
        else:
            print("\n{}[+]{} No se detectaron vulnerabilidades críticas\n".format(
                Colors.OKGREEN, Colors.ENDC
            ))
        
        # Recomendaciones
        if self.vulnerabilities:
            print("\n{}╔═══════════════════════════════════════════════════════════╗".format(Colors.HEADER))
            print("{}║                   RECOMENDACIONES                       ║".format(Colors.HEADER))
            print("{}╚═══════════════════════════════════════════════════════════╝{}\n".format(Colors.HEADER, Colors.ENDC))
            
            print("  1. Cambiar credenciales por defecto inmediatamente")
            print("  2. Restringir acceso a puertos sensibles con firewall")
            print("  3. Usar VPN para acceso administrativo")
            print("  4. Actualizar a última versión parcheada")
            print("  5. Implementar autenticación de dos factores\n")
    
    def scan(self):
        """Ejecuta el escaneo completo"""
        self.print_banner()
        
        # Fase 1: Escaneo de puertos
        self.scan_all_ports()
        
        # Fase 2: Análisis profundo de puertos abiertos
        if self.open_ports:
            print("\n{}[*]{} Iniciando análisis profundo de puertos abiertos...\n".format(
                Colors.OKBLUE, Colors.ENDC
            ))
            
            for port_info in self.open_ports:
                self.deep_scan_port(port_info)
        
        # Fase 3: Reporte
        self.generate_report()


def main():
    """Función principal"""
    
    if len(sys.argv) < 2:
        print("{}Xtream UI Multi-Port Scanner{}\n".format(Colors.BOLD, Colors.ENDC))
        print("Uso: {} <target_ip> [puerto1,puerto2,...]\n".format(sys.argv[0]))
        print("Escanea automáticamente los puertos conocidos de Xtream UI:")
        print("  - 25500 (Admin Panel)")
        print("  - 25461 (HTTP Streaming)")
        print("  - 25462 (RTMP)")
        print("  - 25463 (HTTPS Streaming)")
        print("  - 7999  (MySQL)")
        print("  - 22    (SSH)")
        print("\nEjemplos:")
        print("  {} 192.168.1.100                    # Escaneo automático".format(sys.argv[0]))
        print("  {} 192.168.1.100 8080,9000          # + puertos personalizados\n".format(sys.argv[0]))
        sys.exit(1)
    
    target = sys.argv[1]
    custom_ports = []
    
    # Parsear puertos personalizados
    if len(sys.argv) > 2:
        try:
            custom_ports = [int(p.strip()) for p in sys.argv[2].split(',')]
        except:
            print("{}[ERROR]{} Formato de puerto inválido\n".format(Colors.FAIL, Colors.ENDC))
            sys.exit(1)
    
    scanner = MultiPortScanner(target, custom_ports)
    scanner.scan()
    
    print("\n{}[*]{} Escaneo completado\n".format(Colors.OKGREEN, Colors.ENDC))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n\n{}[!]{} Escaneo interrumpido\n".format(Colors.WARNING, Colors.ENDC))
        sys.exit(0)
    except Exception as e:
        print("\n{}[ERROR]{} {}\n".format(Colors.FAIL, Colors.ENDC, str(e)))
        sys.exit(1)
